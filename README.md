<h1>汇编语言实现的井字棋 Tic-Tac-Toe</h1>

这是一个在 Linux 平台上使用 x86_64 汇编语言编写的简单井字棋（Tic-Tac-Toe）命令行游戏。

## 环境要求

- Ubuntu 或其他兼容的 Linux 发行版
- `nasm`： Netwide Assembler，用于汇编源代码
- `ld`： GNU Linker，用于链接目标文件
- `make`： 用于简化构建过程的工具

在 Ubuntu 上安装依赖：

```bash
sudo apt-get update
sudo apt-get install nasm make
```

## 编译与构建

项目包含一个 `Makefile`，可以方便地进行编译。

### 使用 Make (推荐)

```bash
# 编译项目
make
# 清除生成的文件
make clean
```

### 手动编译

如果你不想使用 make，可以手动运行以下命令：

```bash
# 汇编源码
nasm -f elf64 main.asm -o main.o

# 链接生成可执行文件
ld main.o -o main
```

## 运行游戏

编译完成后，运行生成的可执行文件：

```bash
./main
```

## 游戏规则

1. 游戏在一个 3x3 的网格上进行，初始时每个格子标记为数字 1-9。
2. 玩家 **X** 先手，玩家 **O** 后手。
3. 轮到你时，输入你想落子的格子对应的数字（1-9），然后按回车键。
4. 率先在横向、纵向或对角线上连成一条线的玩家获胜。
5. 如果所有格子都被填满且没有人获胜，则游戏平局。


### 游戏运行示例

```text

 1 | 2 | 3 
---+---+---
 4 | 5 | 6 
---+---+---
 7 | 8 | 9 

Player X, enter a number (1-9): 5

 1 | 2 | 3 
---+---+---
 4 | X | 6 
---+---+---
 7 | 8 | 9 

Player O, enter a number (1-9): 
```
- 胜利
![win](image/win.png)

- 平局
![draw](image/draw.png)

## 代码实现

### 主要使用功能

- **系统调用 (System Calls)**: 直接使用 Linux 内核系统调用进行 I/O 操作。
  - `sys_write (rax=1)`: 用于屏幕输出。
  - `sys_read (rax=0)`: 用于读取用户输入。
  - `sys_exit (rax=60)`: 用于程序退出。
- **内存管理**:
  - `.data` 段：存储预定义的字符串、棋盘状态和提示信息。
  - `.bss` 段：预留空间存储用户输入。
- **程序逻辑**:
  - 使用 `cmp` 和跳转指令 (`je`, `jmp`) 实现游戏循环和条件判断。
  - 使用 `call` 和 `ret` 组织子程序（如打印棋盘、检查胜负）。
  - 寄存器传参：主要使用 `rax`, `rdi`, `rsi`, `rdx` 传递系统调用参数。

### 具体代码实现

代码主要分为三个段：`.data`、`.bss` 和 `.text`。

1.  **数据定义 (`.data`)**
    -   `board`: 使用 9 个字节的数组存储棋盘状态，初始值为 '1'-'9'。
    -   `player`: 存储当前玩家，'X' 或 'O'。
    -   各种提示信息字符串（如 "Player X, enter a number..."）。

2.  **主循环 (`_start` & `game_loop`)**
    -   程序入口 `_start` 初始化游戏。
    -   `game_loop` 是游戏的核心循环：
        1.  `call print_board`: 打印当前棋盘。
        2.  `call get_move`: 获取玩家输入。
        3.  `call check_win`: 检查是否有玩家获胜。
        4.  `call check_draw`: 检查是否平局。
        5.  `call switch_player`: 切换当前玩家。
        6.  跳转回 `game_loop` 继续。

3.  **输入处理 (`get_move`)**
    -   使用 `sys_read` 读取用户输入的字符。
    -   验证输入是否在 '1'-'9' 范围内。
    -   检查目标位置是否已经被占用（即不等于 'X' 或 'O'）。
    -   如果输入无效，递归调用 `get_move` 重新获取。

4.  **胜负判定 (`check_win`)**
    -   通过 `check_rows`、`check_cols`、`check_diags` 分别检查行、列、对角线。
    -   直接比较内存中 `board` 数组特定偏移量的字节值。
    -   如果发现三个连续相同的字符，则返回 1 (rax=1)。

5.  **绘图逻辑 (`print_board`)**
    -   虽然是命令行界面，但通过打印 `|` 和 `---+---+---` 字符构建了可视化的网格。
    -   通过计算偏移量直接访问 `board` 数组中的字符并打印。

## 心得体会

通过使用 x86_64 汇编语言编写这个井字棋游戏，我对计算机底层工作原理有了更深刻的理解：

1.  **直接控制硬件资源**：汇编语言允许直接操作寄存器和内存，这让我明白了高级语言中的变量赋值和函数调用在底层是如何通过 `mov`、`push`、`pop` 等指令实现的。
2.  **系统调用的本质**：直接使用 `syscall` 指令与 Linux 内核交互，让我理解了标准库函数（如 `printf`、`scanf`）背后封装的真实操作。
3.  **逻辑思维的锻炼**：在汇编中，没有高级的 `if-else` 或 `for` 循环结构，所有的逻辑控制都需要通过比较 (`cmp`) 和跳转 (`jmp`/`je`/`jne`) 指令来构建，这对逻辑思维能力是极大的锻炼。
4.  **调试的挑战**：汇编代码的调试比高级语言困难得多，需要时刻关注寄存器的状态和标志位的变化，这培养了严谨的编程习惯。

虽然汇编语言在编写代码方面效率较低，但它在性能优化、系统底层开发以及理解计算机体系结构方面具有不可替代的价值。
